Timers and distribution summaries can be enriched with https://en.wikipedia.org/wiki/Quantile[quantiles] computed in your app prior to shipping to a monitoring backend.

```java
Timer timer = meterRegistry.timerBuilder("my.timer")
                .quantiles(WindowSketchQuantiles.quantiles(0.5, 0.95).create())
                .create();
```

In the above example, two time series will be generated. One represents the median time (0.5), and the other represents the value that places an upper bound on 95% of the samples. These values are sometimes referred to as percentiles - somewhat inaccurately, as the set of percentiles is the set of 100 individual quantile series that equally divide the distribution. That is, percentiles are a specific type of quantile.

Depending on the size of your deployments, computing quantiles like this at instrumentation time may or may not be useful. It is *not possible* to aggregate quantiles across a cluster. Suppose you had a two node cluster, one of which reports a 95% quantile of 100ms for request latency and the other reports a 95% quantile of 50ms. To aggregate in the monitoring backend, you could average the two quantiles to arrive at a 75ms latency, but what if one node receives 1000 requests and the other 10? The proper weighting of the quantiles is lost, making any such aggregation difficult. Nevertheless, if you have a relatively small cluster size, plotting the individual quantiles as separate lines does give you some useful information about the nature of latency across the cluster while providing a visual cue if one node strays from the norm.

For distribution summaries, you can use `summaryBuilder(name)` which mirrors this construction.

This would result in additional gauges with tags `quantile=0.5` and `quantile=0.95`. The 0.95 quantile is the the value below which 95% of observations in a group of observations fall. 0.5 represents the median of our
observations thus far.

It is also possible to indicate that you want to compute quantiles in an `@Timed` annotation:

```java
@RestController
public class MyController {
    @Timed(value = "list.people", quantiles = {0.5, 0.95})
    @GetMapping("/api/people")
    public List<Person> listPeople() { ... }
```

Four quantile algorithms are provided out of the box with different tradeoffs:

* `WindowSketchQuantiles` - The importance of an observation is decayed as it ages. This is the most computationally costly algorithm.

```java
WindowSketchQuantiles.quantiles(0.5, 0.95)
    .error(0.01) // OPTIONAL, defaults to 0.05
    .create()
```

* `Frugal2UQuantiles` - Successive approximation algorithm that converges towards the true quantile with enough observations. This is by least costly algorithm, but exhibits a higher error ratio in early observations.

```java
Frugal2UQuantiles
    // the closer the initial estimate (100) is to the true quantile, the faster it converges
    .quantile(0.95, 100)
    .quantile(0.5, 150)
    .create()
```

* `CKMSQuantiles` - Lets you trade computational complexity for error ratio on a per-quantile basis. Often, it is desirable for higher quantiles to have a lower error ratio (e.g. 0.99 at 1% error vs. 0.5 at 5% error). This algorithm is still more computationally expensive than Frugal.

```java
CKMSQuantiles
    .quantile(0.95, 0.01)
    .quantile(0.5, 0.05)
    .create()
```

* `GKQuantiles` - Lets you trade computational complexity for error ratio across all quantiles. This is used inside of `WindowSketchQuantiles`.

```java
GKQuantiles.quantiles(0.5, 0.95)
    .error(0.01) // OPTIONAL, defaults to 0.05
    .create()
```

Here is a demonstration of all four algorithms operating simultaneously on the same distribution:

image::img/quantile-algorithms.png[Quantile algorithms]

ifeval::["{system}" == "influx"]
The following query is sufficient to graph the 95% latency of a timer in Grafana. Quantile values for Influx are always reported in nanosecond precise time. To represent the Grafana y-axis in milliseconds, we divide by 1000000 in the query.

`SELECT sum("value") / 1000000 FROM "timer" WHERE "quantile" = '0.95' AND $timeFilter GROUP BY time(10s) fill(null)`

endif::[]